

# *************
# Autogenerated from driver file driver_OptIncCompare.py
# *************
import numba
import numpy as np
from math import *
from driver_OptIncCompare import driver

# the total number of species enabled
number_of_species = 1

# the tree species type identifier (integer >= 0) to string name look up table
species_code_to_name = ['ABSI']

# the name to species code look up table
name_to_species_code = {'ABSI': 0}

# the light compensation point (CP) by species
species_code_to_CP = [0.15]

# the SEED value by species
species_code_to_SEED = [0.31]

# the inseeding lag time by species
species_code_to_inseeding_lag = [6]

@numba.jit()
def compute_species_factors_weather(GDD_matrix, drydays_fraction_mat, spp_in_sim):
    '''

    Parameters: GDD_matrix -- a matrix the size of the sim grid of accumulated growing degrees over this year in sim
                drydays_fraction_mat -- the fraction 0 to 1 of the growing season in drought

    Returns:    GDD_3D_spp_factor_matrix -- the species specific degree day factors, size : nx,ny,nspp
                soil_moist_3D_spp_factor_matrix -- the species specific soil moisture factors, size : nx,ny,nspp
    '''
    nx,ny = GDD_matrix.shape
    GDD_3D_spp_factor_matrix = np.zeros((nx,ny,spp_in_sim))
    soil_moist_3D_spp_factor_matrix = np.zeros((nx,ny,spp_in_sim))

    for x in range(nx):
        for y in range(ny):
            for spp in range(spp_in_sim): #address of each cell in 3-D matrix
                if spp == 0:
                    GDD_3D_spp_factor_matrix[x,y,spp] = degree_day_factor_numba_species_0(GDD_matrix[x,y])
                    soil_moist_3D_spp_factor_matrix[x,y,spp] = soil_moisture_factor_numba_species_0(drydays_fraction_mat[x,y])

    return GDD_3D_spp_factor_matrix, soil_moist_3D_spp_factor_matrix

@numba.jit()
def compute_species_factors_soil(relative_soil_fertility_matrix, spp_in_sim):
    '''

    Parameters:  relative_soil_fertility_matrix -- a matrix the size of sim grid with values 0 to 1 for each plot in sim 

    Returns:    soil_fert_3D_spp_factor_matrix -- the species specific soil fertility factors, size : nx,ny,nspp
    '''
    nx,ny = relative_soil_fertility_matrix.shape
    soil_fert_3D_spp_factor_matrix = np.zeros((nx,ny,spp_in_sim))

    for x in range(nx):
        for y in range(ny):
            for spp in range(spp_in_sim): #address of each cell in 3-D matrix
                if spp == 0:
                    soil_fert_3D_spp_factor_matrix[x,y,spp] = soil_fertility_factor_numba_species_0(relative_soil_fertility_matrix[x,y])

    return soil_fert_3D_spp_factor_matrix


def compute_species_factors(GDD_matrix, drydays_fraction_mat, relative_soil_fertility_matrix, spp_in_sim):
    '''

    Parameters: GDD_matrix -- a matrix the size of the sim grid of accumulated growing degrees over this year in sim
                drydays_fraction_mat -- the fraction 0 to 1 of the growing season in drought
                relative_soil_fertility_matrix -- a matrix the size of sim grid with values 0 to 1 for each plot in sim 
                                                  & the conversion from site index to Mg/ha/yr productivity limitation 
                                                  already completed (table in user manual)

#TODO:    Returns:    GDD_3D_spp_factor_matrix -- 
                      soil_moist_3D_spp_factor_matrix -- 
                      soil_fert_3D_spp_factor_matrix --
    '''
    nx,ny = GDD_matrix.shape
    GDD_3D_spp_factor_matrix = np.zeros((nx,ny,spp_in_sim))
    soil_moist_3D_spp_factor_matrix = np.zeros((nx,ny,spp_in_sim))
    soil_fert_3D_spp_factor_matrix = np.zeros((nx,ny,spp_in_sim))

    return compute_species_factors_numba(GDD_matrix, GDD_3D_spp_factor_matrix, 
                                         drydays_fraction_mat, soil_moist_3D_spp_factor_matrix,
                                         relative_soil_fertility_matrix, soil_fert_3D_spp_factor_matrix,
                                         nx, ny, spp_in_sim)

@numba.jit(nopython=True)
def compute_species_factors_numba(GDD_matrix, GDD_3D_spp_factor_matrix, 
                                  drydays_fraction_mat, soil_moist_3D_spp_factor_matrix,
                                  relative_soil_fertility_matrix, soil_fert_3D_spp_factor_matrix,
                                  nx, ny, spp_in_sim):
    for x in range(nx):
        for y in range(ny):
            for spp in range(spp_in_sim): #address of each cell in 3-D matrix
                if spp == 0:
                    GDD_3D_spp_factor_matrix[x,y,spp] = degree_day_factor_numba_species_0(GDD_matrix[x,y])
                    soil_moist_3D_spp_factor_matrix[x,y,spp] = soil_moisture_factor_numba_species_0(drydays_fraction_mat[x,y])
                    soil_fert_3D_spp_factor_matrix[x,y,spp] = soil_fertility_factor_numba_species_0(relative_soil_fertility_matrix[x,y])

    return GDD_3D_spp_factor_matrix, soil_moist_3D_spp_factor_matrix, soil_fert_3D_spp_factor_matrix

@numba.jit()
def compute_available_light_factors_by_species(available_light_mat, dem_offset_index_mat, number_of_species):
    '''
    For the input 3D matrix of available light, compute the species specific light factor for each of the 
    species in the simulation.

    Parameters: available_light_mat -- available light for every location in the simulation 3D area
                                       size 3D: nx, ny, elev (where elev is max tree height + max DEM offset)
                dem_offset_index_mat -- the ground location index within the available_light_mat
                                       size 2D: nx, ny
                number_of_species -- the number of species in the simulation

    Returns: light_factor_by_species_matrix -- species specific light factors computed above ground
                                               size 4D: nx, ny, nz, number_of_species
    '''
    nx, ny, nz = available_light_mat.shape
    light_factor_by_species_matrix = np.zeros((nx,ny,nz,number_of_species))

    # iterate through each plot x,y
    for x in range(nx):
        for y in range(ny):
            # the index where this plot's ground starts
            dem_offset = dem_offset_index_mat[x,y]
            # for each species compute the light factor at every location between the ground and the sky
            for z in range(dem_offset, nz):
                # the available light at this location (x,y,z)
                al = available_light_mat[x,y,z]
                if al > 0.:
                    # compute the factors by species
                    for spp in range(number_of_species):
                        if spp == 0:
                            light_factor_by_species_matrix[x,y,z,spp] = available_light_factor_numba_species_0(al)

    return light_factor_by_species_matrix


@numba.jit()
def compute_available_light_factors_by_speciesV2(available_light_mat, number_of_species):
    '''
    For the input 3D matrix of available light, compute the species specific light factor for each of the 
    species in the simulation.

    Parameters: available_light_mat -- available light for every location in the simulation 3D area
                                       size 3D: nx, ny, elev (where elev is max tree height + max DEM offset)
                number_of_species -- the number of species in the simulation

    Returns: light_factor_by_species_matrix -- species specific light factors computed above ground
                                               size 4D: nx, ny, nz, number_of_species
    '''
    nx, ny, nz = available_light_mat.shape
    light_factor_by_species_matrix = np.zeros((nx,ny,nz,number_of_species))

    # iterate through each plot x,y
    for x in range(nx):
        for y in range(ny):
            # for each species compute the light factor at every location between the ground and the sky
            for z in range(nz):
                # the available light at this location (x,y,z)
                al = available_light_mat[x,y,z]
                if al > 0.:
                    # compute the factors by species
                    for spp in range(number_of_species):
                        if spp == 0:
                            light_factor_by_species_matrix[x,y,z,spp] = available_light_factor_numba_species_0(al)

    return light_factor_by_species_matrix

@numba.jit()
def compute_actual_leaf_area(DBH_matrix, species_code_matrix, crown_base_matrix, tree_height_matrix, total_leaf_area_matrix, 
                             actual_leaf_area_mat, dem_offset_index_mat):
    '''
    Take the computed foliage densities for each tree, and sum them within each plot, creating an accumulated
    foliage density profile for the plot to use as input into the light computation

    Parameters:  DBH_matrix -- records DBH for every tree in sim, size: sim grid by number of trees on each plot
                               size : nx, ny, MAX_TREES_PER_PLOT
                 species_code_matrix -- records the specie of each tree in sim, size: sim grid by number of trees on each plot
                                        size : nx, ny, MAX_TREES_PER_PLOT
                 crown_base_matrix -- records the crown base for each tree in sim, size: sim grid by number of trees 
                                      on each plot
                                      size : nx, ny, MAX_TREES_PER_PLOT
                 tree_height_matrix -- the height of each individual tree on each plot
                                       size : nx, ny, MAX_TREES_PER_PLOT
                 total_leaf_area_matrix -- the total leaf area of each individual tree on each plot
                                           size : nx, ny, MAX_TREES_PER_PLOT
                 actual_leaf_area_mat   --  pre-initialized: contains -1 below ground and 0 above ground for each plot and air space above plot
                                            size: nx, ny, vertical space = (max_tree_ht+(max elevation in sim - min elevation in sim))
                 dem_offset_index_mat   --  size: nx (# plots along E<-->W transect), ny (# plots along N<-->S transect), 1
                                            each x,y contains an index, which specifies the height in meters above the minimum
                                            elevation in the simulation

    Returns:  actual_leaf_area_mat --  contains -1 below ground and *computed value* above ground for each plot and air space above plot
                                       size: nx, ny, vertical space = (max_tree_ht+(max elevation in sim - min elevation in sim))
    '''
    MAX_TREE_HEIGHT = 50
    tree_foliage_popsicle_accumulator_vec = np.zeros(MAX_TREE_HEIGHT)
    nx,ny,ntrees = DBH_matrix.shape
    for x in range(nx):
        for y in range(ny):
            # clear the local popsicle for this plot
            for ht in range(MAX_TREE_HEIGHT):
                tree_foliage_popsicle_accumulator_vec[ht] = 0.
            # iterate through each tree and add to the plot foliage density popsicle
            for individual in range(ntrees): #address of each cell in 3-D matrix
                tree_dbh = DBH_matrix[x,y,individual] #get tree DBH from DBH matrix
                if tree_dbh > 0.0:
                    # foliage density is basically the leaf area / the height
                    tree_height = tree_height_matrix[x,y,individual]
                    crown_base = crown_base_matrix[x,y,individual]
                    crown_length = tree_height - crown_base
                    if crown_length > 0:
                        total_leaf_area = total_leaf_area_matrix[x,y,individual]
                        fd = total_leaf_area / crown_length
                        # accumulate the foliage density popsicle for this plot consisting of many trees on the same DEM elevation
                        for h in range(crown_base, int(tree_height)):
                            tree_foliage_popsicle_accumulator_vec[h] += fd
            # put the plot popsicle into the simulation wide popsicles where each can start at a different height due to the DEM
            leaf_area_profile_base = dem_offset_index_mat[x,y]
            leaf_area_profile_top = dem_offset_index_mat[x,y] + MAX_TREE_HEIGHT
            for height_index, dem_height_index in enumerate(range(leaf_area_profile_base, leaf_area_profile_top)):
                actual_leaf_area_mat[x,y,dem_height_index] = tree_foliage_popsicle_accumulator_vec[height_index]

    return actual_leaf_area_mat

@numba.jit()
def compute_actual_leaf_areaV2(DBH_matrix, species_code_matrix, crown_base_matrix, tree_height_matrix, total_leaf_area_matrix, 
                               actual_leaf_area_mat):
    '''
    Take the computed foliage densities for each tree, and sum them within each plot, creating an accumulated
    foliage density profile for the plot to use as input into the light computation

    Parameters:  DBH_matrix -- records DBH for every tree in sim, size: sim grid by number of trees on each plot
                               size : nx, ny, MAX_TREES_PER_PLOT
                 species_code_matrix -- records the specie of each tree in sim, size: sim grid by number of trees on each plot
                                        size : nx, ny, MAX_TREES_PER_PLOT
                 crown_base_matrix -- records the crown base for each tree in sim, size: sim grid by number of trees 
                                      on each plot
                                      size : nx, ny, MAX_TREES_PER_PLOT
                 tree_height_matrix -- the height of each individual tree on each plot
                                       size : nx, ny, MAX_TREES_PER_PLOT
                 total_leaf_area_matrix -- the total leaf area of each individual tree on each plot
                                           size : nx, ny, MAX_TREES_PER_PLOT
                 actual_leaf_area_mat   --  pre-initialized: contains -1 below ground and 0 above ground for each plot and air space above plot
                                            size: nx, ny, vertical space = (max_tree_ht+(max elevation in sim - min elevation in sim))

    Returns:  actual_leaf_area_mat --  contains contains the actual leaf area column for each plot in the simulation grid
                                       size: nx, ny, MAX_TREE_HEIGHT
    '''
    MAX_TREE_HEIGHT = 50
    nx,ny,ntrees = DBH_matrix.shape
    actual_leaf_area_mat = np.zeros( (nx,ny,MAX_TREE_HEIGHT) )
    for x in range(nx):
        for y in range(ny):
            # iterate through each tree and add to the plot foliage density popsicle
            for individual in range(ntrees): #address of each cell in 3-D matrix
                tree_dbh = DBH_matrix[x,y,individual] #get tree DBH from DBH matrix
                if tree_dbh > 0.0:
                    # foliage density is basically the leaf area / the height
                    tree_height = tree_height_matrix[x,y,individual]
                    crown_base = crown_base_matrix[x,y,individual]
                    crown_length = tree_height - crown_base
                    if crown_length > 0:
                        total_leaf_area = total_leaf_area_matrix[x,y,individual]
                        fd = total_leaf_area / crown_length
                        # accumulate the foliage density popsicle for this plot consisting of many trees on the same DEM elevation
                        for ht in range(crown_base, int(tree_height)):
                            actual_leaf_area_mat[x,y,ht] += fd

    return actual_leaf_area_mat

@numba.jit()
def compute_individual_tree_values(DBH_matrix, species_code_matrix, crown_base_matrix):
    '''
    Compute species specific values for each tree in the simulation.
    The current computed values are:
        individual height (m)
        individual total leaf area (m^2)
        individual biomass (kg)
        optimal growth increment (cm)
        individual optimal biomass (kg)
        individual basal area (m^2)
        individual biovolume (m^3)
        individual optimal biovolume (m^3)
        individual optimal biovolume increment (m^3)

    Parameters : DBH_matrix -- a dbh value (cm) for each tree in the simulation
                               size : nx, ny, ntrees
                 species_code_matrix -- the species code for every tree in the simulation
                                        size : nx, ny, ntrees
                 crown_base_matrix -- the height (m) of the base of each tree crown
                                      size : nx, ny, ntrees

    Returns : tree_height_matrix -- the species specific height (m) of each tree in the simulation
                                    size : nx, ny, ntrees
              total_leaf_area_matrix -- the total leaf area (m^2) of each tree in the simulation
                                        size : nx, ny, ntrees
              biomass_matrix -- the total biomass (kg) of each tree
                                size : nx, ny, ntrees
              opt_inc_matrix -- the optimal dbh increment (cm) that the individual tree can grow under optimal conditions
                                size : nx, ny, ntrees
              optimal_biomass_matrix -- the biomass (kg) that the tree could achieve next year under optimal conditions
                                        size : nx, ny, ntrees
              basal_area_matrix -- the basal area (m^2) for each individual tree
                                   size : nx, ny, ntrees
              biovolume_matrix -- the biovolume (m^3) for each individual tree
                                   size : nx, ny, ntrees
              optimal_biovolume_matrix -- the biovolume (m^3) that the tree could achieve next year under optimal conditions
                                          size : nx, ny, ntrees
              optimal_biovolume_increment_matrix -- the biovolume increment (m^3) that the tree could achieve next year under optimal conditions
                                                    size : nx, ny, ntrees
    '''
    nx,ny,ntrees = DBH_matrix.shape
    tree_height_matrix = np.zeros((nx,ny,ntrees))
    total_leaf_area_matrix = np.zeros((nx,ny,ntrees))
    biomass_matrix = np.zeros((nx,ny,ntrees))
    opt_inc_matrix = np.zeros((nx,ny,ntrees))
    optimal_biomass_matrix = np.zeros((nx,ny,ntrees))
    basal_area_matrix = np.zeros((nx,ny,ntrees))
    biovolume_matrix = np.zeros((nx,ny,ntrees))
    optimal_biovolume_matrix = np.zeros((nx,ny,ntrees))
    optimal_biovolume_increment_matrix = np.zeros((nx,ny,ntrees))

    for x in range(nx):
        for y in range(ny):
            for ind in range(ntrees):
                dbh = DBH_matrix[x,y,ind]
                crown_base = crown_base_matrix[x,y,ind]
                species_code = species_code_matrix[x,y,ind]
                if species_code == 0:                
                    tree_height = tree_height_numba_species_0(dbh)
                    tree_height_matrix[x,y,ind] = tree_height
                    total_leaf_area_matrix[x,y,ind] = total_leaf_area_numba_species_0(dbh, tree_height, crown_base)
                    biomass_matrix[x,y,ind] = tree_biomass_numba_species_0(dbh)
                    opt_inc = optimal_growth_increment_numba_species_0(dbh)
                    opt_inc_matrix[x,y,ind] = opt_inc
                    optimal_biomass_matrix[x,y,ind] = tree_biomass_numba_species_0(dbh + opt_inc)
                    basal_area_matrix[x,y,ind] = basal_area_numba_species_0(dbh)
                    biovolume_matrix[x,y,ind] = tree_biovolume_numba_species_0(dbh)
                    optimal_biovolume_matrix[x,y,ind] = tree_biovolume_numba_species_0(dbh + opt_inc)
                    optimal_biovolume_increment_matrix[x,y,ind] = optimal_biovolume_matrix[x,y,ind] - biovolume_matrix[x,y,ind]

    return tree_height_matrix, total_leaf_area_matrix, biomass_matrix, opt_inc_matrix, optimal_biomass_matrix, basal_area_matrix, biovolume_matrix,            optimal_biovolume_matrix, optimal_biovolume_increment_matrix


# ********************************
# By specie code
# ********************************

# ***** Species Code 0
#  ABSI:
#    AGE_MORTALITY_EQUATION: <function standard_age_mortality_probablity_fn__0 at 0x7f0d9f44eaa0>
#    AVAILABLE_LIGHT_FACTOR_EQUATION: <function standard_available_light_factor_fn__5 at 0x7f0d9f44ecf8>
#    BASAL_AREA_EQUATION: <function standard_basal_area at 0x7f0d9f4435f0>
#    BIOMASS_EQUATION: <function absi_total_biomass at 0x7f0d9f44e668>
#    BIOVOLUME_EQUATION: <function absi_biovolume at 0x7f0d9f44e1b8>
#    DEGREE_DAY_FACTOR_EQUATION: <function standard_degree_day_factor_fn__4 at 0x7f0d9f44ec80>
#    DMAX: 80.0
#    ENABLED: True
#    INSEEDING_LAG: 6
#    LEAF_AREA_EQUATION: <function absi_leaf_area_fn at 0x7f0d9f443de8>
#    LIGHT_COMPENSATION_POINT: 0.15
#    OPTIMAL_GROWTH_INCREMENT_EQUATION: <function bragg_optimal_growth_increment_innerfn__1 at 0x7f0d9f44eb18>
#    SEED: 0.31
#    SOIL_FERTILITY_FACTOR_EQUATION: <function standard_soil_fertility_factor_fn__2 at 0x7f0d9f44eb90>
#    SOIL_MOISTURE_FACTOR_EQUATION: <function standard_soil_moisture_factor_fn__3 at 0x7f0d9f44ec08>
#    TREE_HEIGHT_EQUATION: <function absi_tree_height at 0x7f0d9f443aa0>


# species specific degree day factor equation (see driver)
degree_day_factor_numba_species_0 = numba.jit(nopython=True)(driver['species']['ABSI']['DEGREE_DAY_FACTOR_EQUATION'])

# species specific soil moisture factor equation (see driver)
soil_moisture_factor_numba_species_0 = numba.jit(nopython=True)(driver['species']['ABSI']['SOIL_MOISTURE_FACTOR_EQUATION'])

# species specific soil fertility factor equation (see driver)
soil_fertility_factor_numba_species_0 = numba.jit(nopython=True)(driver['species']['ABSI']['SOIL_FERTILITY_FACTOR_EQUATION'])

# species specific light factor equation (see driver)
available_light_factor_numba_species_0 = numba.jit(nopython=True)(driver['species']['ABSI']['AVAILABLE_LIGHT_FACTOR_EQUATION'])

# species specific tree height equation (see driver)
tree_height_numba_species_0 = numba.jit(nopython=True)(driver['species']['ABSI']['TREE_HEIGHT_EQUATION'])

# species specific leaf area equation (see driver)
leaf_area_numba_species_0 = numba.jit(nopython=True)(driver['species']['ABSI']['LEAF_AREA_EQUATION'])

@numba.jit(nopython=True)
def total_leaf_area_numba_species_0(dbh, tree_height, crown_base):
    '''
    Compute the total leaf area for a single tree.

    Parameters: dbh -- the tree dbh in cm
                tree_height -- the height of the tree in meters
                crown_base -- the height of the base of the crown in meters

    Returns: the total leaf area in m^2
    '''
    leaf_area = leaf_area_numba_species_0(dbh)
    adjusted_leaf_area = leaf_area * (tree_height - crown_base)/tree_height  #drop the leaves below crown base
    return adjusted_leaf_area

# species specific biomass equation (see driver)
tree_biomass_numba_species_0 = numba.jit(nopython=True)(driver['species']['ABSI']['BIOMASS_EQUATION'])

# species specific biovolume equation (see driver)
tree_biovolume_numba_species_0 = numba.jit(nopython=True)(driver['species']['ABSI']['BIOVOLUME_EQUATION'])

# species specific optimal growth increment equation (see driver)
optimal_growth_increment_numba_species_0 = numba.jit(nopython=True)(driver['species']['ABSI']['OPTIMAL_GROWTH_INCREMENT_EQUATION'])

# species specific basal area function (see driver)
basal_area_numba_species_0 = numba.jit(nopython=True)(driver['species']['ABSI']['BASAL_AREA_EQUATION'])

# species specific age mortality probability function (see driver)
age_mortality_probablity_numba_species_0 = numba.jit(nopython=True)(driver['species']['ABSI']['AGE_MORTALITY_EQUATION'])


# the age mortality probability functions by species
species_code_to_age_mortality_function = [ age_mortality_probablity_numba_species_0, ]

